<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="LSQR -- Sparse Least Squares Solver with Modern Fortran">
    
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>LSQR &ndash; LSQR</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">LSQR </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
        
            <li><a href="../lists/absint.html">Abstract Interfaces</a></li>
               
            <li><a href="../lists/types.html">Derived Types</a></li>
        
               
        
        
            </ul>
        
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/absint.html">Abstract Interfaces</a></li>
                             
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>




          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  
  <div class="row">
    <h1>LSQR
      <small>Subroutine</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title="38.0% of total for procedures.">231 statements</a>
     </li> 
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/lsqr.f90"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
     <li><a href='../sourcefile/lsqr.f90.html'>lsqr.f90</a></li>
    
     <li><a href='../module/lsqr_module.html'>lsqr_module</a></li>
    
  
     <li class="active">LSQR</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>
 





















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../proc/lsqr.html#src">LSQR</a>
  </div>
</div>



</div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>
private subroutine LSQR(me, m, n, damp, wantse, u, v, w, x, se, atol, btol, conlim, itnlim, nout, istop, itn, anorm, acond, rnorm, arnorm, xnorm)
    
    
   
</h2>
    
  


    
    <p>LSQR finds a solution <script type="math/tex">x</script> to the following problems:</p>
<ol>
<li>Unsymmetric equations -- solve:  <script type="math/tex; mode=display"> \mathbf{A} \cdot \mathbf{x} = \mathbf{b} </script>
</li>
<li>Linear least squares  -- solve (in the least-squares sense):  <script type="math/tex; mode=display"> \mathbf{A} \cdot \mathbf{x} = \mathbf{b} </script>
</li>
<li>Damped least squares  -- solve (in the least-squares sense): <script type="math/tex; mode=display"> \left[ \begin{array}{c} \mathbf{A}\\ damp \cdot \mathbf{I} \end{array} \right] \cdot \mathbf{x} = \left[ \begin{array}{c} \mathbf{b}\\ \mathbf{0} \end{array} \right] </script>
</li>
</ol>
<p>where A is a matrix with m rows and n columns, b is an
  m-vector, and <code>damp</code> is a scalar.  (All quantities are real.)
  The matrix A is intended to be large and sparse.  It is accessed
  by means of subroutine calls to <code>aprod</code>.</p>
<p>The rhs vector b is input via u, and subsequently overwritten.</p>
<p>Note:  LSQR uses an iterative method to approximate the solution.
  The number of iterations required to reach a certain accuracy
  depends strongly on the scaling of the problem.  Poor scaling of
  the rows or columns of A should therefore be avoided where
  possible.</p>
<p>For example, in problem 1 the solution is unaltered by
  row-scaling.  If a row of A is very small or large compared to
  the other rows of A, the corresponding row of ( A  b ) should be
  scaled up or down.</p>
<p>In problems 1 and 2, the solution x is easily recovered
  following column-scaling.  Unless better information is known,
  the nonzero columns of A should be scaled so that they all have
  the same Euclidean norm (e.g., 1.0).</p>
<p>In problem 3, there is no freedom to re-scale if damp is
  nonzero.  However, the value of damp should be assigned only
  after attention has been paid to the scaling of A.</p>
<p>The parameter damp is intended to help regularize
  ill-conditioned systems, by preventing the true solution from
  being very large.  Another aid to regularization is provided by
  the parameter acond, which may be used to terminate iterations
  before the computed solution becomes very large.</p>
<p>Note that x is not an input parameter.
  If some initial estimate x0 is known and if damp = 0,
  one could proceed as follows:</p>
<ol>
<li>Compute a residual vector     <script type="math/tex"> r_0 = b - A \cdot x_0 </script>.</li>
<li>Use LSQR to solve the system  <script type="math/tex"> A \cdot \Delta x = r_0 </script>.</li>
<li>Add the correction dx to obtain a final solution <script type="math/tex"> x = x_0 + \Delta x </script>.</li>
</ol>
<p>This requires that x0 be available before and after the call
  to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations
  to solve A<em>x = b and k2 iterations to solve A</em>dx = r0.
  If x0 is "good", norm(r0) will be smaller than norm(b).
  If the same stopping tolerances atol and btol are used for each
  system, k1 and k2 will be similar, but the final solution x0 + dx
  should be more accurate.  The only way to reduce the total work
  is to use a larger stopping tolerance for the second system.
  If some value btol is suitable for A<em>x = b, the larger value
  btol</em>norm(b)/norm(r0)  should be suitable for A*dx = r0.</p>
<p>Preconditioning is another way to reduce the number of iterations.
  If it is possible to solve a related system M<em>x = b efficiently,
  where M approximates A in some helpful way
  (e.g. M - A has low rank or its elements are small relative to
  those of A), LSQR may converge more rapidly on the system
        A</em>M(inverse)<em>z = b,
  after which x can be recovered by solving M</em>x = z.</p>
<p>NOTE: If A is symmetric, LSQR should not be used!
  Alternatives are the symmetric conjugate-gradient method (cg)
  and/or SYMMLQ.
  SYMMLQ is an implementation of symmetric cg that applies to
  any symmetric A and will converge more rapidly than LSQR.
  If A is positive definite, there are other implementations of
  symmetric cg that require slightly less work per iteration
  than SYMMLQ (but will take the same number of iterations).</p>
<h3>Notation</h3>
<p>The following quantities are used in discussing the subroutine
 parameters:</p>
<div class="codehilite"><pre><span></span><code>     Abar   =  (   A    ),         bbar  =  ( b )
               ( damp*I )                   ( 0 )

     r      = b  -  A*x,           rbar  = bbar  -  Abar*x

     rnorm  = sqrt( norm(r)**2  +  damp**2 * norm(x)**2 )
            = norm( rbar )

     relpr  = the relative precision of floating-point arithmetic
              on the machine being used.  On most machines,
              relpr is about 1.0e-7 and 1.0d-16 in single and double
              precision respectively.
</code></pre></div>

<p>LSQR  minimizes the function <code>rnorm</code> with respect to <code>x</code>.</p>
<h3>References</h3>
<ul>
<li>
<p>C.C. Paige and M.A. Saunders,  LSQR: An algorithm for sparse
    linear equations and sparse least squares,
    ACM Transactions on Mathematical Software 8, 1 (March 1982),
    pp. 43-71.</p>
</li>
<li>
<p>C.C. Paige and M.A. Saunders,  Algorithm 583, LSQR: Sparse
    linear equations and least-squares problems,
    ACM Transactions on Mathematical Software 8, 2 (June 1982),
    pp. 195-209.</p>
</li>
<li>
<p>C.L. Lawson, R.J. Hanson, D.R. Kincaid and F.T. Krogh,
    Basic linear algebra subprograms for Fortran usage,
    ACM Transactions on Mathematical Software 5, 3 (Sept 1979),
    pp. 308-323 and 324-325.</p>
</li>
</ul>
<h3>LSQR development</h3>
<ul>
<li>22 Feb 1982: LSQR sent to ACM TOMS to become Algorithm 583.</li>
<li>15 Sep 1985: Final F66 version.  LSQR sent to "misc" in netlib.</li>
<li>13 Oct 1987: Bug (Robert Davies, DSIR).  Have to delete
                     if ( (one + dabs(t)) &lt;= one ) GO TO 200
                  from loop 200.  The test was an attempt to reduce
                  underflows, but caused w(i) not to be updated.</li>
<li>17 Mar 1989: First F77 version.</li>
<li>04 May 1989: Bug (David Gay, AT&amp;T).  When the second beta is zero,
                  rnorm = 0 and
                  test2 = arnorm / (anorm * rnorm) overflows.
                  Fixed by testing for rnorm = 0.</li>
<li>05 May 1989: Sent to "misc" in netlib.</li>
<li>14 Mar 1990: Bug (John Tomlin via IBM OSL testing).
                  Setting rhbar2 = rhobar**2 + dampsq can give zero
                  if rhobar underflows and damp = 0.
                  Fixed by testing for damp = 0 specially.</li>
<li>15 Mar 1990: Converted to lower case.</li>
<li>21 Mar 1990: d2norm introduced to avoid overflow in numerous
                  items like  c = sqrt( a<strong>2 + b</strong>2 ).</li>
<li>04 Sep 1991: wantse added as an argument to LSQR, to make
                  standard errors optional.  This saves storage and
                  time when se(*) is not wanted.</li>
<li>13 Feb 1992: istop now returns a value in [1,5], not [1,7].
                  1, 2 or 3 means that x solves one of the problems
                  Ax = b,  min norm(Ax - b)  or  damped least squares.
                  4 means the limit on cond(A) was reached.
                  5 means the limit on iterations was reached.</li>
<li>07 Dec 1994: Keep track of dxmax = max_k norm( phi_k * d_k ).
                  So far, this is just printed at the end.
                  A large value (relative to norm(x)) indicates
                  significant cancellation in forming
                  x  = D*f  = sum( phi_k * d_k ).
                  A large column of D need NOT be serious if the
                  corresponding phi_k is small.</li>
<li>27 Dec 1994: Include estimate of alfa_opt in iteration log.
                  alfa_opt is the optimal scale factor for the
                  residual in the "augmented system", as described by
                  A. Bjorck (1992),
                  Pivoting and stability in the augmented system method,
                  in D. F. Griffiths and G. A. Watson (eds.),
                  "Numerical Analysis 1991",
                  Proceedings of the 14th Dundee Conference,
                  Pitman Research Notes in Mathematics 260,
                  Longman Scientific and Technical, Harlow, Essex, 1992.</li>
<li>12 Nov 2019 : Jacob Williams : significant refactoring into modern Fortran.</li>
</ul>
<h3>Author</h3>
<ul>
<li>Michael A. Saunders, Dept of Operations Research, Stanford University</li>
</ul>
<p></p><div class="alert alert-info" role="alert"><h4>Note</h4><p>The number of iterations required by LSQR will usually decrease
      if the computation is performed in higher precision.</p></div>
    

    <h3>Arguments</h3>
    
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-me~5"></span>class(<a href='../type/lsqr_solver.html'>lsqr_solver</a>),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>me</strong></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-m~5"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>m</strong></td><td><p>the number of rows in <code>A</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-n~9"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of columns in <code>A</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-damp~2"></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>damp</strong></td><td><p>The damping parameter for problem 3 above.
(damp should be 0.0 for problems 1 and 2.)
If the system <code>A*x = b</code> is incompatible, values
of <code>damp</code> in the range 0 to <code>sqrt(relpr)*norm(A)</code>
will probably have a negligible effect.
Larger values of <code>damp</code> will tend to decrease
the norm of <code>x</code> and reduce the number of
iterations required by LSQR.</p>
<p>The work per iteration and the storage needed
by LSQR are the same for all values of <code>damp</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-wantse"></span>logical,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>wantse</strong></td><td><p>A logical variable to say if the array <code>se(*)</code>
of standard error estimates should be computed.
If <code>m &gt; n</code>  or  <code>damp &gt; 0</code>,  the system is
overdetermined and the standard errors may be
useful.  (See the first LSQR reference.)
Otherwise (<code>m &lt;= n</code>  and  <code>damp = 0</code>) they do not
mean much.  Some time and storage can be saved
by setting <code>wantse = .false.</code> and using any
convenient array for <code>se(*)</code>, which won't be
touched.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-u"></span>real(kind=wp),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>u</strong>(m)</td><td><p>The rhs vector <code>b</code>.  Beware that <code>u</code> is
over-written by LSQR.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-v~2"></span>real(kind=wp),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>v</strong>(n)</td><td><p>workspace</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-w~2"></span>real(kind=wp),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>w</strong>(n)</td><td><p>workspace</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-x~5"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>Returns the computed solution <code>x</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-se~2"></span>real(kind=wp),</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(*)</td><td>::</td>
  <td><strong>se</strong></td><td><p>If <code>wantse</code> is true, the dimension of <code>se</code> must be
<code>n</code> or more. <code>se(*)</code> then returns standard error
estimates for the components of <code>x</code>.
For each <code>i</code>, <code>se(i)</code> is set to the value
<code>rnorm * sqrt( sigma(i,i) / t )</code>,
where <code>sigma(i,i)</code> is an estimate of the i-th
diagonal of the inverse of <code>Abar(transpose)*Abar</code>
and:
* <code>t = 1      if  m &lt;= n</code>
* <code>t = m - n  if  m &gt; n  and  damp = 0</code>
* <code>t = m      if  damp /= 0</code></p>
<p>If <code>wantse</code> is false, <code>se(*)</code> will not be touched.
The actual parameter can be any suitable array
of any length.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-atol~3"></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>atol</strong></td><td><p>An estimate of the relative error in the data
defining the matrix <code>A</code>.  For example,
if <code>A</code> is accurate to about 6 digits, set
<code>atol = 1.0e-6</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-btol~3"></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>btol</strong></td><td><p>An estimate of the relative error in the data
defining the rhs vector <code>b</code>.  For example,
if <code>b</code> is accurate to about 6 digits, set
<code>btol = 1.0e-6</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-conlim~3"></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>conlim</strong></td><td><p>An upper limit on <code>cond(Abar)</code>, the apparent
condition number of the matrix <code>Abar</code>.
Iterations will be terminated if a computed
estimate of <code>cond(Abar)</code> exceeds <code>conlim</code>.
This is intended to prevent certain small or
zero singular values of <code>A</code> or <code>Abar</code> from
coming into effect and causing unwanted growth
in the computed solution.</p>
<p><code>conlim</code> and <code>damp</code> may be used separately or
together to regularize ill-conditioned systems.</p>
<p>Normally, <code>conlim</code> should be in the range
1000 to <code>1/relpr</code>.</p>
<p>Suggested value:</p>
<ul>
<li><code>conlim = 1/(100*relpr)</code> for compatible systems,</li>
<li><code>conlim = 1/(10*sqrt(relpr))</code> for least squares.</li>
</ul>
<p>Note:  If the user is not concerned about the parameters
<code>atol</code>, <code>btol</code> and <code>conlim</code>, any or all of them may be set
to zero.  The effect will be the same as the values
<code>relpr</code>, <code>relpr</code> and <code>1/relpr</code> respectively.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-itnlim~3"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>itnlim</strong></td><td><p>An upper limit on the number of iterations.
Suggested value:
* <code>itnlim = n/2</code> for well-conditioned systems
  with clustered singular values,
* <code>itnlim = 4*n</code> otherwise.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nout~3"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>nout</strong></td><td><p>File number for printed output.  If nonzero,
a summary will be printed on file <code>nout</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-istop~2"></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>istop</strong></td><td><p>An integer giving the reason for termination:</p>
<ul>
<li>0 -- <code>x</code> = 0  is the exact solution.
  No iterations were performed.</li>
<li>1 -- The equations <code>A*x = b</code> are probably
  compatible.  <code>Norm(A*x - b)</code> is sufficiently
  small, given the values of <code>atol</code> and <code>btol</code>.</li>
<li>2 -- <code>damp</code> is zero.  The system <code>A*x = b</code> is probably
  not compatible.  A least-squares solution has
  been obtained that is sufficiently accurate,
  given the value of <code>atol</code>.</li>
<li>3 -- <code>damp</code> is nonzero.  A damped least-squares
  solution has been obtained that is sufficiently
  accurate, given the value of <code>atol</code>.</li>
<li>4 -- An estimate of <code>cond(Abar)</code> has exceeded
  <code>conlim</code>.  The system <code>A*x = b</code> appears to be
  ill-conditioned.  Otherwise, there could be an
  error in subroutine <code>aprod</code>.</li>
<li>5 -- The iteration limit <code>itnlim</code> was reached.</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-itn~2"></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>itn</strong></td><td><p>The number of iterations performed.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-anorm~2"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>anorm</strong></td><td><p>An estimate of the Frobenius norm of <code>Abar</code>.
This is the square-root of the sum of squares
of the elements of <code>Abar</code>.
If <code>damp</code> is small and if the columns of <code>A</code>
have all been scaled to have length 1.0,
<code>anorm</code> should increase to roughly <code>sqrt(n)</code>.
A radically different value for <code>anorm</code> may
indicate an error in subroutine <code>aprod</code> (there
may be an inconsistency between modes 1 and 2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-acond~2"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>acond</strong></td><td><p>An estimate of <code>cond(Abar)</code>, the condition
number of <code>Abar</code>.  A very high value of <code>acond</code>
may again indicate an error in <code>aprod</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-rnorm~2"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>rnorm</strong></td><td><p>An estimate of the final value of <code>norm(rbar)</code>,
the function being minimized (see notation
above).  This will be small if <code>A*x = b</code> has
a solution.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-arnorm~2"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>arnorm</strong></td><td><p>An estimate of the final value of
<code>norm( Abar(transpose)*rbar )</code>, the norm of
the residual for the usual normal equations.
This should be small in all cases.  (arnorm
will often be smaller than the true value
computed from the output vector <code>x</code>.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-xnorm~2"></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>xnorm</strong></td><td><p>An estimate of the norm of the final
solution vector <code>x</code>.</p></td>
  
</tr>

</tbody>
</table>

    
    
    
    <br>
    
    
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Calls</h3>
      </div>
      <div class="panel-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~lsqr~~CallsGraph Pages: 1 -->
<svg id="proclsqrCallsGraph" width="153pt" height="158pt"
 viewBox="0.00 0.00 153.00 158.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~lsqr~~CallsGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 154)">
<title>proc~~lsqr~~CallsGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-154 149,-154 149,4 -4,4"/>
<!-- proc~lsqr -->
<g id="proc~~lsqr~~CallsGraph_node1" class="node">
<title>proc~lsqr</title>
<polygon fill="none" stroke="black" points="54,-87 0,-87 0,-63 54,-63 54,-87"/>
<text text-anchor="middle" x="27" y="-72.6" font-family="Helvetica,sans-Serif" font-size="10.50">LSQR</text>
</g>
<!-- proc~d2norm -->
<g id="proc~~lsqr~~CallsGraph_node2" class="node">
<title>proc~d2norm</title>
<g id="a_proc~~lsqr~~CallsGraph_node2"><a xlink:href=".././proc/d2norm.html" xlink:title="d2norm">
<polygon fill="#d94e8f" stroke="#d94e8f" points="145,-150 90,-150 90,-126 145,-126 145,-150"/>
<text text-anchor="middle" x="117.5" y="-135.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">d2norm</text>
</a>
</g>
</g>
<!-- proc~lsqr&#45;&gt;proc~d2norm -->
<g id="proc~~lsqr~~CallsGraph_edge1" class="edge">
<title>proc~lsqr&#45;&gt;proc~d2norm</title>
<path fill="none" stroke="#000000" d="M45.06,-87.15C58.16,-96.47 76.45,-109.49 91.25,-120.02"/>
<polygon fill="#000000" stroke="#000000" points="89.31,-122.94 99.49,-125.89 93.37,-117.24 89.31,-122.94"/>
</g>
<!-- proc~dcopy -->
<g id="proc~~lsqr~~CallsGraph_node3" class="node">
<title>proc~dcopy</title>
<g id="a_proc~~lsqr~~CallsGraph_node3"><a xlink:href=".././proc/dcopy.html" xlink:title="dcopy">
<polygon fill="#d9534f" stroke="#d9534f" points="144.5,-108 90.5,-108 90.5,-84 144.5,-84 144.5,-108"/>
<text text-anchor="middle" x="117.5" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">dcopy</text>
</a>
</g>
</g>
<!-- proc~lsqr&#45;&gt;proc~dcopy -->
<g id="proc~~lsqr~~CallsGraph_edge2" class="edge">
<title>proc~lsqr&#45;&gt;proc~dcopy</title>
<path fill="none" stroke="#000000" d="M54.07,-81.19C62.37,-83.16 71.7,-85.37 80.57,-87.47"/>
<polygon fill="#000000" stroke="#000000" points="79.77,-90.88 90.31,-89.78 81.38,-84.07 79.77,-90.88"/>
</g>
<!-- proc~dscal -->
<g id="proc~~lsqr~~CallsGraph_node4" class="node">
<title>proc~dscal</title>
<g id="a_proc~~lsqr~~CallsGraph_node4"><a xlink:href=".././proc/dscal.html" xlink:title="dscal">
<polygon fill="#d9534f" stroke="#d9534f" points="144.5,-66 90.5,-66 90.5,-42 144.5,-42 144.5,-66"/>
<text text-anchor="middle" x="117.5" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">dscal</text>
</a>
</g>
</g>
<!-- proc~lsqr&#45;&gt;proc~dscal -->
<g id="proc~~lsqr~~CallsGraph_edge3" class="edge">
<title>proc~lsqr&#45;&gt;proc~dscal</title>
<path fill="none" stroke="#000000" d="M54.07,-68.81C62.37,-66.84 71.7,-64.63 80.57,-62.53"/>
<polygon fill="#000000" stroke="#000000" points="81.38,-65.93 90.31,-60.22 79.77,-59.12 81.38,-65.93"/>
</g>
<!-- proc~dnrm2 -->
<g id="proc~~lsqr~~CallsGraph_node5" class="node">
<title>proc~dnrm2</title>
<g id="a_proc~~lsqr~~CallsGraph_node5"><a xlink:href=".././proc/dnrm2.html" xlink:title="dnrm2">
<polygon fill="#d94e8f" stroke="#d94e8f" points="144.5,-24 90.5,-24 90.5,0 144.5,0 144.5,-24"/>
<text text-anchor="middle" x="117.5" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">dnrm2</text>
</a>
</g>
</g>
<!-- proc~lsqr&#45;&gt;proc~dnrm2 -->
<g id="proc~~lsqr~~CallsGraph_edge4" class="edge">
<title>proc~lsqr&#45;&gt;proc~dnrm2</title>
<path fill="none" stroke="#000000" d="M45.06,-62.85C58.16,-53.53 76.45,-40.51 91.25,-29.98"/>
<polygon fill="#000000" stroke="#000000" points="93.37,-32.76 99.49,-24.11 89.31,-27.06 93.37,-32.76"/>
</g>
</g>
</svg>
</div><div><a type="button" class="graph-help" data-toggle="modal" href="#graph-help-text">Help</a></div><div class="modal fade" id="graph-help-text" tabindex="-1" role="dialog"><div class="modal-dialog modal-lg" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><h4 class="modal-title" id="-graph-help-label">Graph Key</h4></div><div class="modal-body">
    <p>Nodes of different colours represent the following: </p>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="597pt" height="32pt"
 viewBox="0.00 0.00 596.50 32.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 592.5,-28 592.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node4" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="388.5,-24 243.5,-24 243.5,0 388.5,0 388.5,-24"/>
<text text-anchor="middle" x="316" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node5" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="465,-24 407,-24 407,0 465,0 465,-24"/>
<text text-anchor="middle" x="436" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node6" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="588.5,-24 483.5,-24 483.5,0 588.5,0 588.5,-24"/>
<text text-anchor="middle" x="536" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

    
    <p>Solid arrows point from a procedure to one which it calls. Dashed 
    arrows point from an interface to procedures which implement that interface.
    This could include the module procedures in a generic interface or the
    implementation in a submodule of an interface in a parent module.
    </p>
    </div></div></div></div>
      </div>
    </div>
     
     
    <br>

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>
 





















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../proc/lsqr.html#src">LSQR</a>
  </div>
</div>



    </section>
    <br class="visible-xs visible-sm hidden-md">

    

    
    
    
    
    

    
    
    
    
    


    
    
    
    <section>
    <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="highlight"><pre><span></span>   <span class="k">subroutine </span><span class="n">LSQR</span>  <span class="p">(</span> <span class="n">me</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">damp</span><span class="p">,</span> <span class="n">wantse</span><span class="p">,</span> <span class="p">&amp;</span>
                     <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="p">&amp;</span>
                     <span class="n">atol</span><span class="p">,</span> <span class="n">btol</span><span class="p">,</span> <span class="n">conlim</span><span class="p">,</span> <span class="n">itnlim</span><span class="p">,</span> <span class="n">nout</span><span class="p">,</span> <span class="p">&amp;</span>
                     <span class="n">istop</span><span class="p">,</span> <span class="n">itn</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">acond</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">arnorm</span><span class="p">,</span> <span class="n">xnorm</span><span class="p">)</span>

   <span class="k">class</span><span class="p">(</span><span class="n">lsqr_solver</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span> <span class="kd">::</span> <span class="n">me</span>
   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">m</span>          <span class="c">!! the number of rows in `A`.</span>
   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">n</span>          <span class="c">!! the number of columns in `A`.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">damp</span>       <span class="c">!! The damping parameter for problem 3 above.</span>
                                       <span class="c">!! (damp should be 0.0 for problems 1 and 2.)</span>
                                       <span class="c">!! If the system `A*x = b` is incompatible, values</span>
                                       <span class="c">!! of `damp` in the range 0 to `sqrt(relpr)*norm(A)`</span>
                                       <span class="c">!! will probably have a negligible effect.</span>
                                       <span class="c">!! Larger values of `damp` will tend to decrease</span>
                                       <span class="c">!! the norm of `x` and reduce the number of</span>
                                       <span class="c">!! iterations required by LSQR.</span>
                                       <span class="c">!!</span>
                                       <span class="c">!! The work per iteration and the storage needed</span>
                                       <span class="c">!! by LSQR are the same for all values of `damp`.</span>
   <span class="kt">logical</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>    <span class="kd">::</span> <span class="n">wantse</span>     <span class="c">!! A logical variable to say if the array `se(*)`</span>
                                       <span class="c">!! of standard error estimates should be computed.</span>
                                       <span class="c">!! If `m &gt; n`  or  `damp &gt; 0`,  the system is</span>
                                       <span class="c">!! overdetermined and the standard errors may be</span>
                                       <span class="c">!! useful.  (See the first LSQR reference.)</span>
                                       <span class="c">!! Otherwise (`m &lt;= n`  and  `damp = 0`) they do not</span>
                                       <span class="c">!! mean much.  Some time and storage can be saved</span>
                                       <span class="c">!! by setting `wantse = .false.` and using any</span>
                                       <span class="c">!! convenient array for `se(*)`, which won&#39;t be</span>
                                       <span class="c">!! touched.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span> <span class="n">u</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>       <span class="c">!! The rhs vector `b`.  Beware that `u` is</span>
                                       <span class="c">!! over-written by LSQR.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>       <span class="c">!! workspace</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">inout</span><span class="p">)</span><span class="kd">::</span> <span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>       <span class="c">!! workspace</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>       <span class="c">!! Returns the computed solution `x`.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">dimension</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="kd">::</span> <span class="n">se</span>   <span class="c">!! If `wantse` is true, the dimension of `se` must be</span>
                                             <span class="c">!! `n` or more. `se(*)` then returns standard error</span>
                                             <span class="c">!! estimates for the components of `x`.</span>
                                             <span class="c">!! For each `i`, `se(i)` is set to the value</span>
                                             <span class="c">!! `rnorm * sqrt( sigma(i,i) / t )`,</span>
                                             <span class="c">!! where `sigma(i,i)` is an estimate of the i-th</span>
                                             <span class="c">!! diagonal of the inverse of `Abar(transpose)*Abar`</span>
                                             <span class="c">!! and:</span>
                                             <span class="c">!! * `t = 1      if  m &lt;= n`</span>
                                             <span class="c">!! * `t = m - n  if  m &gt; n  and  damp = 0`</span>
                                             <span class="c">!! * `t = m      if  damp /= 0`</span>
                                             <span class="c">!!</span>
                                             <span class="c">!! If `wantse` is false, `se(*)` will not be touched.</span>
                                             <span class="c">!! The actual parameter can be any suitable array</span>
                                             <span class="c">!! of any length.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">atol</span>       <span class="c">!! An estimate of the relative error in the data</span>
                                       <span class="c">!! defining the matrix `A`.  For example,</span>
                                       <span class="c">!! if `A` is accurate to about 6 digits, set</span>
                                       <span class="c">!! `atol = 1.0e-6`.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">btol</span>       <span class="c">!! An estimate of the relative error in the data</span>
                                       <span class="c">!! defining the rhs vector `b`.  For example,</span>
                                       <span class="c">!! if `b` is accurate to about 6 digits, set</span>
                                       <span class="c">!! `btol = 1.0e-6`.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>              <span class="kd">::</span> <span class="n">conlim</span>   <span class="c">!! An upper limit on `cond(Abar)`, the apparent</span>
                                                <span class="c">!! condition number of the matrix `Abar`.</span>
                                                <span class="c">!! Iterations will be terminated if a computed</span>
                                                <span class="c">!! estimate of `cond(Abar)` exceeds `conlim`.</span>
                                                <span class="c">!! This is intended to prevent certain small or</span>
                                                <span class="c">!! zero singular values of `A` or `Abar` from</span>
                                                <span class="c">!! coming into effect and causing unwanted growth</span>
                                                <span class="c">!! in the computed solution.</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! `conlim` and `damp` may be used separately or</span>
                                                <span class="c">!! together to regularize ill-conditioned systems.</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! Normally, `conlim` should be in the range</span>
                                                <span class="c">!! 1000 to `1/relpr`.</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! Suggested value:</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! * `conlim = 1/(100*relpr)` for compatible systems,</span>
                                                <span class="c">!! * `conlim = 1/(10*sqrt(relpr))` for least squares.</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! Note:  If the user is not concerned about the parameters</span>
                                                <span class="c">!! `atol`, `btol` and `conlim`, any or all of them may be set</span>
                                                <span class="c">!! to zero.  The effect will be the same as the values</span>
                                                <span class="c">!! `relpr`, `relpr` and `1/relpr` respectively.</span>
   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>               <span class="kd">::</span> <span class="n">itnlim</span>   <span class="c">!! An upper limit on the number of iterations.</span>
                                                <span class="c">!! Suggested value:</span>
                                                <span class="c">!! * `itnlim = n/2` for well-conditioned systems</span>
                                                <span class="c">!!   with clustered singular values,</span>
                                                <span class="c">!! * `itnlim = 4*n` otherwise.</span>
   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span>               <span class="kd">::</span> <span class="n">nout</span>     <span class="c">!! File number for printed output.  If nonzero,</span>
                                                <span class="c">!! a summary will be printed on file `nout`.</span>
   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>               <span class="kd">::</span> <span class="n">istop</span>   <span class="c">!! An integer giving the reason for termination:</span>
                                                <span class="c">!!</span>
                                                <span class="c">!! * 0 -- `x` = 0  is the exact solution.</span>
                                                <span class="c">!!   No iterations were performed.</span>
                                                <span class="c">!! * 1 -- The equations `A*x = b` are probably</span>
                                                <span class="c">!!   compatible.  `Norm(A*x - b)` is sufficiently</span>
                                                <span class="c">!!   small, given the values of `atol` and `btol`.</span>
                                                <span class="c">!! * 2 -- `damp` is zero.  The system `A*x = b` is probably</span>
                                                <span class="c">!!   not compatible.  A least-squares solution has</span>
                                                <span class="c">!!   been obtained that is sufficiently accurate,</span>
                                                <span class="c">!!   given the value of `atol`.</span>
                                                <span class="c">!! * 3 -- `damp` is nonzero.  A damped least-squares</span>
                                                <span class="c">!!   solution has been obtained that is sufficiently</span>
                                                <span class="c">!!   accurate, given the value of `atol`.</span>
                                                <span class="c">!! * 4 -- An estimate of `cond(Abar)` has exceeded</span>
                                                <span class="c">!!   `conlim`.  The system `A*x = b` appears to be</span>
                                                <span class="c">!!   ill-conditioned.  Otherwise, there could be an</span>
                                                <span class="c">!!   error in subroutine `aprod`.</span>
                                                <span class="c">!! * 5 -- The iteration limit `itnlim` was reached.</span>
   <span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>   <span class="kd">::</span> <span class="n">itn</span>        <span class="c">!! The number of iterations performed.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">anorm</span>      <span class="c">!! An estimate of the Frobenius norm of `Abar`.</span>
                                       <span class="c">!! This is the square-root of the sum of squares</span>
                                       <span class="c">!! of the elements of `Abar`.</span>
                                       <span class="c">!! If `damp` is small and if the columns of `A`</span>
                                       <span class="c">!! have all been scaled to have length 1.0,</span>
                                       <span class="c">!! `anorm` should increase to roughly `sqrt(n)`.</span>
                                       <span class="c">!! A radically different value for `anorm` may</span>
                                       <span class="c">!! indicate an error in subroutine `aprod` (there</span>
                                       <span class="c">!! may be an inconsistency between modes 1 and 2).</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">acond</span>      <span class="c">!! An estimate of `cond(Abar)`, the condition</span>
                                       <span class="c">!! number of `Abar`.  A very high value of `acond`</span>
                                       <span class="c">!! may again indicate an error in `aprod`.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">rnorm</span>      <span class="c">!! An estimate of the final value of `norm(rbar)`,</span>
                                       <span class="c">!! the function being minimized (see notation</span>
                                       <span class="c">!! above).  This will be small if `A*x = b` has</span>
                                       <span class="c">!! a solution.</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">arnorm</span>     <span class="c">!! An estimate of the final value of</span>
                                       <span class="c">!! `norm( Abar(transpose)*rbar )`, the norm of</span>
                                       <span class="c">!! the residual for the usual normal equations.</span>
                                       <span class="c">!! This should be small in all cases.  (arnorm</span>
                                       <span class="c">!! will often be smaller than the true value</span>
                                       <span class="c">!! computed from the output vector `x`.)</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  <span class="kd">::</span> <span class="n">xnorm</span>      <span class="c">!! An estimate of the norm of the final</span>
                                       <span class="c">!! solution vector `x`.</span>

   <span class="kt">logical</span> <span class="kd">::</span> <span class="n">damped</span>
   <span class="kt">integer</span> <span class="kd">::</span> <span class="n">i</span><span class="p">,</span> <span class="n">maxdx</span><span class="p">,</span> <span class="n">nconv</span><span class="p">,</span> <span class="n">nstop</span>
   <span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="kd">::</span> <span class="n">alfopt</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">bnorm</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">cs</span><span class="p">,</span> <span class="n">cs1</span><span class="p">,</span> <span class="n">cs2</span><span class="p">,</span> <span class="n">ctol</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">delta</span><span class="p">,</span> <span class="n">dknorm</span><span class="p">,</span> <span class="n">dnorm</span><span class="p">,</span> <span class="n">dxk</span><span class="p">,</span> <span class="n">dxmax</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="nb">gamma</span><span class="p">,</span> <span class="n">gambar</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">phibar</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">res2</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">rhobar</span><span class="p">,</span> <span class="n">rhbar1</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">rhs</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">sn</span><span class="p">,</span> <span class="n">sn1</span><span class="p">,</span> <span class="n">sn2</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">t</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">test1</span><span class="p">,</span> <span class="n">test2</span><span class="p">,</span> <span class="n">test3</span><span class="p">,</span> <span class="p">&amp;</span>
               <span class="n">theta</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span><span class="p">,</span> <span class="n">xnorm1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">zbar</span>
   <span class="kt">logical</span> <span class="kd">::</span> <span class="n">print_iter</span>

   <span class="kt">logical</span><span class="p">,</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">extra</span> <span class="o">=</span> <span class="p">.</span><span class="n">true</span><span class="p">.</span>  <span class="c">!! for extra printing below.</span>

   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">enter</span> <span class="o">=</span> <span class="s1">&#39; Enter LSQR.  &#39;</span>
   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span><span class="k">parameter</span> <span class="kd">::</span> <span class="k">exit</span>  <span class="o">=</span> <span class="s1">&#39; Exit  LSQR.  &#39;</span>
   <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span><span class="k">dimension</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">),</span><span class="k">parameter</span> <span class="kd">::</span> <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span> <span class="s1">&#39;The exact solution is x = 0                          &#39;</span><span class="p">,&amp;</span>
                                                        <span class="s1">&#39;A solution to Ax = b was found, given atol, btol     &#39;</span><span class="p">,&amp;</span>
                                                        <span class="s1">&#39;A least-squares solution was found, given atol       &#39;</span><span class="p">,&amp;</span>
                                                        <span class="s1">&#39;A damped least-squares solution was found, given atol&#39;</span><span class="p">,&amp;</span>
                                                        <span class="s1">&#39;Cond(Abar) seems to be too large, given conlim       &#39;</span><span class="p">,&amp;</span>
                                                        <span class="s1">&#39;The iteration limit was reached                      &#39;</span> <span class="p">]</span>

   <span class="c">! Initialize.</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">nout</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span><span class="s1">&#39;(//A)&#39;</span><span class="p">)</span> <span class="n">enter</span><span class="o">//</span><span class="s1">&#39;     Least-squares solution of  Ax = b&#39;</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span><span class="s1">&#39;(A,I7,A,I7,A)&#39;</span><span class="p">)</span> <span class="s1">&#39; The matrix  A  has&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="s1">&#39; rows   and&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s1">&#39; columns&#39;</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span><span class="s1">&#39;(1P,A,E22.14,3X,A,L10)&#39;</span><span class="p">)</span>   <span class="s1">&#39; damp   =&#39;</span><span class="p">,</span> <span class="n">damp</span><span class="p">,</span> <span class="s1">&#39;wantse =&#39;</span><span class="p">,</span> <span class="n">wantse</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span><span class="s1">&#39;(1P,A,E10.2,15x,A,E10.2)&#39;</span><span class="p">)</span> <span class="s1">&#39; atol   =&#39;</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="s1">&#39;conlim =&#39;</span><span class="p">,</span> <span class="n">conlim</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span><span class="s1">&#39;(1P,A,E10.2,15x,A,I10)&#39;</span><span class="p">)</span>   <span class="s1">&#39; btol   =&#39;</span><span class="p">,</span> <span class="n">btol</span><span class="p">,</span> <span class="s1">&#39;itnlim =&#39;</span><span class="p">,</span> <span class="n">itnlim</span>
   <span class="k">end if</span>

<span class="k">   </span><span class="n">damped</span> <span class="o">=</span> <span class="n">damp</span> <span class="o">&gt;</span> <span class="n">zero</span>
   <span class="n">itn</span>  <span class="o">=</span> <span class="mi">0</span>
   <span class="n">istop</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="n">nstop</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="n">maxdx</span> <span class="o">=</span> <span class="mi">0</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">conlim</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      </span><span class="n">ctol</span> <span class="o">=</span> <span class="n">one</span> <span class="o">/</span> <span class="n">conlim</span>
   <span class="k">else</span>
<span class="k">      </span><span class="n">ctol</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="k">end if</span>
<span class="k">   </span><span class="n">anorm</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">acond</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">dnorm</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">dxmax</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">res2</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">psi</span>  <span class="o">=</span> <span class="n">zero</span>
   <span class="n">xnorm</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">xnorm1</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">cs2</span>    <span class="o">=</span> <span class="o">-</span> <span class="n">one</span>
   <span class="n">sn2</span>  <span class="o">=</span> <span class="n">zero</span>
   <span class="n">z</span>    <span class="o">=</span> <span class="n">zero</span>

   <span class="c">! Set up the first vectors u and v for the bidiagonalization.</span>
   <span class="c">! These satisfy  beta*u = b,  alpha*v = A(transpose)*u.</span>
   <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
      <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">=</span> <span class="n">zero</span>
      <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">=</span> <span class="n">zero</span>
   <span class="k">end do</span>

<span class="k">   if</span> <span class="p">(</span> <span class="n">wantse</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">      do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
         <span class="n">se</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">zero</span>
      <span class="k">end do</span>
<span class="k">   end if</span>

<span class="k">   </span><span class="n">alpha</span> <span class="o">=</span> <span class="n">zero</span>
   <span class="n">beta</span> <span class="o">=</span> <span class="n">dnrm2</span> <span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      call </span><span class="n">dscal</span> <span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">one</span> <span class="o">/</span> <span class="n">beta</span><span class="p">),</span> <span class="n">u</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
      <span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">aprod</span> <span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="p">)</span>
      <span class="n">alpha</span> <span class="o">=</span> <span class="n">dnrm2</span> <span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
   <span class="k">end if</span>

<span class="k">   if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      call </span><span class="n">dscal</span> <span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">one</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
      <span class="k">call </span><span class="n">dcopy</span> <span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
   <span class="k">end if</span>

<span class="k">   </span><span class="n">arnorm</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">arnorm</span> <span class="o">/=</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>

<span class="k">      </span><span class="n">rhobar</span> <span class="o">=</span> <span class="n">alpha</span>
      <span class="n">phibar</span> <span class="o">=</span> <span class="n">beta</span>
      <span class="n">bnorm</span> <span class="o">=</span> <span class="n">beta</span>
      <span class="n">rnorm</span> <span class="o">=</span> <span class="n">beta</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">nout</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">         if</span> <span class="p">(</span> <span class="n">damped</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">            write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(//A)&#39;</span><span class="p">)</span> <span class="p">&amp;</span>
               <span class="s1">&#39;   Itn       x(1)           Function     Compatible   LS     Norm Abar Cond Abar&#39;</span>
         <span class="k">else</span>
<span class="k">            write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(//A)&#39;</span><span class="p">)</span> <span class="p">&amp;</span>
               <span class="s1">&#39;   Itn       x(1)           Function     Compatible   LS        Norm A    Cond A&#39;</span>
         <span class="k">end if</span>
<span class="k">         </span><span class="n">test1</span>  <span class="o">=</span> <span class="n">one</span>
         <span class="n">test2</span>  <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">beta</span>

         <span class="k">if</span> <span class="p">(</span> <span class="n">extra</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">            write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(80X,A)&#39;</span><span class="p">)</span> <span class="s1">&#39;    phi    dknorm   dxk  alfa_opt&#39;</span>
         <span class="k">end if</span>
<span class="k">         write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)&#39;</span><span class="p">)</span> <span class="n">itn</span><span class="p">,</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">test1</span><span class="p">,</span> <span class="n">test2</span>
         <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(A)&#39;</span><span class="p">)</span> <span class="s1">&#39;&#39;</span>
      <span class="k">end if</span>

<span class="k">      do</span>
         <span class="c">! Main iteration loop.</span>
         <span class="n">itn</span> <span class="o">=</span> <span class="n">itn</span> <span class="o">+</span> <span class="mi">1</span>

         <span class="c">! Perform the next step of the bidiagonalization to obtain the</span>
         <span class="c">! next  beta, u, alpha, v.  These satisfy the relations</span>
         <span class="c">! beta*u  = A*v  -  alpha*u,</span>
         <span class="c">! alpha*v  = A(transpose)*u  -  beta*v.</span>
         <span class="k">call </span><span class="n">dscal</span> <span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span> <span class="n">alpha</span><span class="p">),</span> <span class="n">u</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
         <span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">aprod</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="p">)</span>
         <span class="n">beta</span> <span class="o">=</span> <span class="n">dnrm2</span> <span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>

         <span class="c">! Accumulate  anorm = || Bk || = sqrt( sum of  alpha**2 + beta**2 + damp**2 ).</span>

         <span class="n">temp</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="p">)</span>
         <span class="n">temp</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">temp</span> <span class="p">,</span> <span class="n">damp</span> <span class="p">)</span>
         <span class="n">anorm</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">temp</span> <span class="p">)</span>

         <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">            call </span><span class="n">dscal</span> <span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">one</span> <span class="o">/</span> <span class="n">beta</span><span class="p">),</span> <span class="n">u</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="k">call </span><span class="n">dscal</span> <span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span> <span class="n">beta</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="k">call </span><span class="n">me</span><span class="p">%</span><span class="n">aprod</span> <span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">dnrm2</span> <span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="k">then</span>
<span class="k">               call </span><span class="n">dscal</span> <span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">one</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
            <span class="k">end if</span>
<span class="k">         end if</span>

         <span class="c">! Use a plane rotation to eliminate the damping parameter.</span>
         <span class="c">! This alters the diagonal (rhobar) of the lower-bidiagonal matrix.</span>
         <span class="n">rhbar1</span> <span class="o">=</span> <span class="n">rhobar</span>
         <span class="k">if</span> <span class="p">(</span> <span class="n">damped</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">            </span><span class="n">rhbar1</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">rhobar</span><span class="p">,</span> <span class="n">damp</span> <span class="p">)</span>
            <span class="n">cs1</span>    <span class="o">=</span> <span class="n">rhobar</span> <span class="o">/</span> <span class="n">rhbar1</span>
            <span class="n">sn1</span>    <span class="o">=</span> <span class="n">damp</span>   <span class="o">/</span> <span class="n">rhbar1</span>
            <span class="n">psi</span>    <span class="o">=</span> <span class="n">sn1</span> <span class="o">*</span> <span class="n">phibar</span>
            <span class="n">phibar</span> <span class="o">=</span> <span class="n">cs1</span> <span class="o">*</span> <span class="n">phibar</span>
         <span class="k">end if</span>

         <span class="c">! Use a plane rotation to eliminate the subdiagonal element (beta)</span>
         <span class="c">! of the lower-bidiagonal matrix, giving an upper-bidiagonal matrix.</span>
         <span class="n">rho</span>  <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">rhbar1</span><span class="p">,</span> <span class="n">beta</span> <span class="p">)</span>
         <span class="n">cs</span>   <span class="o">=</span> <span class="n">rhbar1</span> <span class="o">/</span> <span class="n">rho</span>
         <span class="n">sn</span>   <span class="o">=</span> <span class="n">beta</span>   <span class="o">/</span> <span class="n">rho</span>
         <span class="n">theta</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">alpha</span>
         <span class="n">rhobar</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cs</span> <span class="o">*</span> <span class="n">alpha</span>
         <span class="n">phi</span>  <span class="o">=</span> <span class="n">cs</span> <span class="o">*</span> <span class="n">phibar</span>
         <span class="n">phibar</span> <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">phibar</span>
         <span class="n">tau</span>  <span class="o">=</span> <span class="n">sn</span> <span class="o">*</span> <span class="n">phi</span>

         <span class="c">! Update  x, w  and (perhaps) the standard error estimates.</span>
         <span class="n">t1</span>   <span class="o">=</span> <span class="n">phi</span>   <span class="o">/</span> <span class="n">rho</span>
         <span class="n">t2</span>   <span class="o">=</span> <span class="o">-</span> <span class="n">theta</span> <span class="o">/</span> <span class="n">rho</span>
         <span class="n">t3</span>   <span class="o">=</span> <span class="n">one</span>   <span class="o">/</span> <span class="n">rho</span>
         <span class="n">dknorm</span> <span class="o">=</span> <span class="n">zero</span>

         <span class="k">if</span> <span class="p">(</span> <span class="n">wantse</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">            do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
               <span class="n">t</span>      <span class="o">=</span> <span class="n">w</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">t</span>  <span class="o">+</span>  <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">w</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   <span class="o">=</span> <span class="n">t2</span><span class="o">*</span><span class="n">t</span>  <span class="o">+</span>  <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">t</span>      <span class="o">=</span> <span class="p">(</span><span class="n">t3</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
               <span class="n">se</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="o">=</span> <span class="n">t</span>     <span class="o">+</span>  <span class="n">se</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">dknorm</span> <span class="o">=</span> <span class="n">t</span>     <span class="o">+</span>  <span class="n">dknorm</span>
            <span class="k">end do</span>
<span class="k">         else</span>
<span class="k">            do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
               <span class="n">t</span>      <span class="o">=</span> <span class="n">w</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">t</span>  <span class="o">+</span>  <span class="n">x</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">w</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>   <span class="o">=</span> <span class="n">t2</span><span class="o">*</span><span class="n">t</span>  <span class="o">+</span>  <span class="n">v</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
               <span class="n">dknorm</span> <span class="o">=</span> <span class="p">(</span><span class="n">t3</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>  <span class="o">+</span>  <span class="n">dknorm</span>
            <span class="k">end do</span>
<span class="k">         end if</span>

         <span class="c">! Monitor the norm of d_k, the update to x.</span>
         <span class="c">! dknorm = norm( d_k )</span>
         <span class="c">! dnorm  = norm( D_k ),        where   D_k = (d_1, d_2, ..., d_k )</span>
         <span class="c">! dxk    = norm( phi_k d_k ),  where new x = x_k + phi_k d_k.</span>
         <span class="n">dknorm</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="n">dknorm</span> <span class="p">)</span>
         <span class="n">dnorm</span>  <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">dnorm</span><span class="p">,</span> <span class="n">dknorm</span> <span class="p">)</span>
         <span class="n">dxk</span>    <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">dknorm</span> <span class="p">)</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">dxmax</span> <span class="o">&lt;</span> <span class="n">dxk</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">            </span><span class="n">dxmax</span>   <span class="o">=</span> <span class="n">dxk</span>
            <span class="n">maxdx</span>   <span class="o">=</span> <span class="n">itn</span>
         <span class="k">end if</span>

         <span class="c">! Use a plane rotation on the right to eliminate the</span>
         <span class="c">! super-diagonal element (theta) of the upper-bidiagonal matrix.</span>
         <span class="c">! Then use the result to estimate  norm(x).</span>
         <span class="n">delta</span> <span class="o">=</span> <span class="n">sn2</span> <span class="o">*</span> <span class="n">rho</span>
         <span class="n">gambar</span> <span class="o">=</span> <span class="o">-</span> <span class="n">cs2</span> <span class="o">*</span> <span class="n">rho</span>
         <span class="n">rhs</span>  <span class="o">=</span> <span class="n">phi</span>    <span class="o">-</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">z</span>
         <span class="n">zbar</span> <span class="o">=</span> <span class="n">rhs</span>    <span class="o">/</span> <span class="n">gambar</span>
         <span class="n">xnorm</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">xnorm1</span><span class="p">,</span> <span class="n">zbar</span>  <span class="p">)</span>
         <span class="nb">gamma</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">gambar</span><span class="p">,</span> <span class="n">theta</span> <span class="p">)</span>
         <span class="n">cs2</span>  <span class="o">=</span> <span class="n">gambar</span> <span class="o">/</span> <span class="nb">gamma</span>
<span class="nb">         </span><span class="n">sn2</span>  <span class="o">=</span> <span class="n">theta</span>  <span class="o">/</span> <span class="nb">gamma</span>
<span class="nb">         </span><span class="n">z</span>    <span class="o">=</span> <span class="n">rhs</span>    <span class="o">/</span> <span class="nb">gamma</span>
<span class="nb">         </span><span class="n">xnorm1</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">xnorm1</span><span class="p">,</span> <span class="n">z</span>     <span class="p">)</span>

         <span class="c">! Test for convergence.</span>
         <span class="c">! First, estimate the norm and condition of the matrix  Abar,</span>
         <span class="c">! and the norms of  rbar  and  Abar(transpose)*rbar.</span>
         <span class="n">acond</span> <span class="o">=</span> <span class="n">anorm</span> <span class="o">*</span> <span class="n">dnorm</span>
         <span class="n">res2</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">res2</span> <span class="p">,</span> <span class="n">psi</span>    <span class="p">)</span>
         <span class="n">rnorm</span> <span class="o">=</span> <span class="n">d2norm</span><span class="p">(</span> <span class="n">res2</span> <span class="p">,</span> <span class="n">phibar</span> <span class="p">)</span>
         <span class="n">arnorm</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span> <span class="n">tau</span> <span class="p">)</span>

         <span class="c">! Now use these norms to estimate certain other quantities,</span>
         <span class="c">! some of which will be small near a solution.</span>

         <span class="n">alfopt</span> <span class="o">=</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="n">rnorm</span> <span class="o">/</span> <span class="p">(</span><span class="n">dnorm</span> <span class="o">*</span> <span class="n">xnorm</span><span class="p">)</span> <span class="p">)</span>
         <span class="n">test1</span> <span class="o">=</span> <span class="n">rnorm</span> <span class="o">/</span>  <span class="n">bnorm</span>
         <span class="n">test2</span> <span class="o">=</span> <span class="n">zero</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">rnorm</span> <span class="o">&gt;</span> <span class="n">zero</span><span class="p">)</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">arnorm</span> <span class="o">/</span> <span class="p">(</span><span class="n">anorm</span> <span class="o">*</span> <span class="n">rnorm</span><span class="p">)</span>
         <span class="n">test3</span> <span class="o">=</span> <span class="n">one</span>   <span class="o">/</span>  <span class="n">acond</span>
         <span class="n">t1</span>   <span class="o">=</span> <span class="n">test1</span> <span class="o">/</span> <span class="p">(</span><span class="n">one</span>  <span class="o">+</span>  <span class="n">anorm</span> <span class="o">*</span> <span class="n">xnorm</span> <span class="o">/</span> <span class="n">bnorm</span><span class="p">)</span>
         <span class="n">rtol</span> <span class="o">=</span> <span class="n">btol</span>  <span class="o">+</span>  <span class="n">atol</span> <span class="o">*</span>  <span class="n">anorm</span> <span class="o">*</span> <span class="n">xnorm</span> <span class="o">/</span> <span class="n">bnorm</span>

         <span class="c">! The following tests guard against extremely small values of</span>
         <span class="c">! atol, btol  or  ctol.  (The user may have set any or all of</span>
         <span class="c">! the parameters  atol, btol, conlim  to zero.)</span>
         <span class="c">! The effect is equivalent to the normal tests using</span>
         <span class="c">! atol = relpr,  btol = relpr,  conlim = 1/relpr.</span>

         <span class="n">t3</span>   <span class="o">=</span> <span class="n">one</span> <span class="o">+</span> <span class="n">test3</span>
         <span class="n">t2</span>   <span class="o">=</span> <span class="n">one</span> <span class="o">+</span> <span class="n">test2</span>
         <span class="n">t1</span>   <span class="o">=</span> <span class="n">one</span> <span class="o">+</span> <span class="n">t1</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">itn</span> <span class="o">&gt;=</span> <span class="n">itnlim</span><span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">5</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">t3</span>  <span class="o">&lt;=</span> <span class="n">one</span>   <span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">4</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">t2</span>  <span class="o">&lt;=</span> <span class="n">one</span>   <span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">2</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">t1</span>  <span class="o">&lt;=</span> <span class="n">one</span>   <span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">1</span>

         <span class="c">! Allow for tolerances set by the user.</span>

         <span class="k">if</span> <span class="p">(</span><span class="n">test3</span> <span class="o">&lt;=</span> <span class="n">ctol</span><span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">4</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">test2</span> <span class="o">&lt;=</span> <span class="n">atol</span><span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">2</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">test1</span> <span class="o">&lt;=</span> <span class="n">rtol</span><span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">1</span>

         <span class="c">! See if it is time to print something.</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">nout</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>

<span class="k">            </span><span class="n">print_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span>     <span class="o">&lt;=</span> <span class="mi">40</span>       <span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="n">itn</span>   <span class="o">&lt;=</span> <span class="mi">10</span>       <span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="n">itn</span>   <span class="o">&gt;=</span> <span class="n">itnlim</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="nb">mod</span><span class="p">(</span><span class="n">itn</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>  <span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="n">test3</span> <span class="o">&lt;=</span>  <span class="mf">2.0</span><span class="o">*</span><span class="n">ctol</span><span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="n">test2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="mf">0.0</span><span class="o">*</span><span class="n">atol</span><span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="n">test1</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="mf">0.0</span><span class="o">*</span><span class="n">rtol</span><span class="p">)</span> <span class="p">.</span><span class="nb">or</span><span class="p">.</span> <span class="p">&amp;</span>
                         <span class="p">(</span><span class="n">istop</span> <span class="o">/=</span>  <span class="mi">0</span>       <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">print_iter</span><span class="p">)</span> <span class="k">then</span>
               <span class="c">! Print a line for this iteration.</span>
               <span class="c">! &quot;extra&quot; is for experimental purposes.</span>
               <span class="k">if</span> <span class="p">(</span> <span class="n">extra</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">                  write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)&#39;</span><span class="p">)</span> <span class="p">&amp;</span>
                           <span class="n">itn</span><span class="p">,</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">test1</span><span class="p">,</span> <span class="n">test2</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">acond</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dknorm</span><span class="p">,</span> <span class="n">dxk</span><span class="p">,</span> <span class="n">alfopt</span>
               <span class="k">else</span>
<span class="k">                  write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P, I6, 2E17.9, 4E10.2, E9.1, 3E8.1)&#39;</span><span class="p">)</span> <span class="p">&amp;</span>
                           <span class="n">itn</span><span class="p">,</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">rnorm</span><span class="p">,</span> <span class="n">test1</span><span class="p">,</span> <span class="n">test2</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">acond</span>
               <span class="k">end if</span>
               <span class="c">!if (mod(itn,10) == 0) write(nout, &#39;(A)&#39;) &#39;&#39;</span>
            <span class="k">end if</span>

<span class="k">         end if</span>

         <span class="c">! Stop if appropriate.</span>
         <span class="c">! The convergence criteria are required to be met on nconv</span>
         <span class="c">! consecutive iterations, where nconv is set below.</span>
         <span class="c">! Suggested value:  nconv = 1, 2 or 3.</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">istop</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">            </span><span class="n">nstop</span>  <span class="o">=</span> <span class="mi">0</span>
         <span class="k">else</span>
<span class="k">            </span><span class="n">nconv</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="n">nstop</span>  <span class="o">=</span> <span class="n">nstop</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nstop</span> <span class="o">&lt;</span> <span class="n">nconv</span>  <span class="p">.</span><span class="nb">and</span><span class="p">.</span>  <span class="n">itn</span> <span class="o">&lt;</span> <span class="n">itnlim</span><span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">0</span>
         <span class="k">end if</span>
<span class="k">         if</span> <span class="p">(</span><span class="n">istop</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">exit</span>

<span class="k">      end do</span>
      <span class="c">! End of iteration loop.</span>

      <span class="c">! Finish off the standard error estimates.</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">wantse</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">         </span><span class="n">t</span> <span class="o">=</span> <span class="n">one</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span>  <span class="n">t</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">n</span>
         <span class="k">if</span> <span class="p">(</span> <span class="n">damped</span> <span class="p">)</span>  <span class="n">t</span> <span class="o">=</span> <span class="n">m</span>
         <span class="n">t</span> <span class="o">=</span> <span class="n">rnorm</span> <span class="o">/</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span>
         <span class="k">do </span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span>
            <span class="n">se</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="nb">sqrt</span><span class="p">(</span> <span class="n">se</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span>
         <span class="k">end do</span>
<span class="k">      end if</span>

<span class="k">   end if</span>

   <span class="c">! Decide if istop = 2 or 3.</span>
   <span class="c">! Print the stopping condition.</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">damped</span> <span class="p">.</span><span class="nb">and</span><span class="p">.</span> <span class="n">istop</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">istop</span> <span class="o">=</span> <span class="mi">3</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">nout</span> <span class="o">/=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">      write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(//A,5X,A,I2,15X,A,I8)&#39;</span><span class="p">)</span>       <span class="k">exit</span><span class="p">,</span> <span class="s1">&#39;istop  =&#39;</span><span class="p">,</span> <span class="n">istop</span><span class="p">,</span> <span class="s1">&#39;itn    =&#39;</span><span class="p">,</span> <span class="n">itn</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P,A,5X,A,E12.5,5X,A,E12.5)&#39;</span><span class="p">)</span> <span class="k">exit</span><span class="p">,</span> <span class="s1">&#39;anorm  =&#39;</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="s1">&#39;acond  =&#39;</span><span class="p">,</span> <span class="n">acond</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P,A,5X,A,E12.5,5X,A,E12.5)&#39;</span><span class="p">)</span> <span class="k">exit</span><span class="p">,</span> <span class="s1">&#39;bnorm  =&#39;</span><span class="p">,</span> <span class="n">bnorm</span><span class="p">,</span> <span class="s1">&#39;xnorm  =&#39;</span><span class="p">,</span> <span class="n">xnorm</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P,A,5X,A,E12.5,5X,A,E12.5)&#39;</span><span class="p">)</span> <span class="k">exit</span><span class="p">,</span> <span class="s1">&#39;rnorm  =&#39;</span><span class="p">,</span> <span class="n">rnorm</span><span class="p">,</span> <span class="s1">&#39;arnorm =&#39;</span><span class="p">,</span> <span class="n">arnorm</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P,A,5X,A,E8.1,A,I8)&#39;</span><span class="p">)</span>        <span class="k">exit</span><span class="p">,</span> <span class="s1">&#39;max dx =&#39;</span><span class="p">,</span> <span class="n">dxmax</span><span class="p">,</span> <span class="s1">&#39; occurred at itn &#39;</span><span class="p">,</span><span class="n">maxdx</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(1P,A,5X,A,E8.1,A)&#39;</span>   <span class="p">)</span>        <span class="k">exit</span><span class="p">,</span> <span class="s1">&#39;       =&#39;</span><span class="p">,</span> <span class="n">dxmax</span><span class="o">/</span><span class="p">(</span><span class="n">xnorm</span> <span class="o">+</span> <span class="mf">1.0e-20_wp</span><span class="p">),</span> <span class="s1">&#39;*xnorm&#39;</span>
      <span class="k">write</span><span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="s1">&#39;(A,5X,A)&#39;</span> <span class="p">)</span>                    <span class="k">exit</span><span class="p">,</span> <span class="n">msg</span><span class="p">(</span><span class="n">istop</span><span class="p">)</span>
   <span class="k">end if</span>

<span class="k">   end subroutine </span><span class="n">LSQR</span>
</pre></div>

    </section>
    <br>
    
    
    </div>
  </div>


    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-6"><p>LSQR was developed by Jacob Williams<br>&copy; 2021 
                                          </p>
        </div>
        <div class="col-xs-6 col-md-6">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            
            
          </p>
        </div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>